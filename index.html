<html>

<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>


    <style>
        .durak-readonly {
            background-color: lightgray;
        }
    </style>

</head>

<body>
    <div id="app">
        <div>
            <button class="button" @click="host">host</button>
            <button class="button" @click="join">join</button>
        </div>
        <div v-if="mode == 'host'">
            <div>offer:</div>
            <div class="field has-addons">
                <p class="control">
                    <span class="button has-text-info" @click="clipboard(offer)">
                        <i class="fas fa-copy"></i>
                    </span>
                </p>
                <p class="control">
                    <input class="input durak-readonly" v-model="offer" readonly></input>
                </p>
            </div>
            <div v-if="!answer">please enter answer:</div>
            <div v-if="answer">answer:</div>
            <input class="input" v-model="potential_answer" :readonly="answer"
                v-bind:class="{ 'durak-readonly': answer }"></input>
            <button class="button" v-if="!answer" @click="accept_answer">submit</button>

            <div v-if="answer">
                <div>candidates:</div>
                <div class="field has-addons" v-for="ice_candidate in ice_candidates">
                    <p class="control">
                        <span class="button has-text-info" @click="clipboard(ice_candidate)">
                            <i class="fas fa-copy"></i>
                        </span>
                    </p>
                    <p class="control">
                        <input class="input durak-readonly" :value="ice_candidate" readonly>
                        </input>
                    </p>
                </div>
            </div>

            <div v-if="connected">
                <div>local data:</div>
                <textarea class="textarea" v-model="local_data"></textarea>
                <div>remote data:</div>
                <textarea class="textarea durak-readonly" v-model="remote_data" readonly></textarea>
            </div>
        </div>
        <div v-if="mode == 'join'">
            <div v-if="!offer">please enter offer:</div>
            <div v-if="offer">offer:</div>
            <input class="input" v-model="potential_offer" :readonly="offer"
                v-bind:class="{ 'durak-readonly': offer }"></input>
            <button class="button" v-if="!offer" @click="accept_offer">submit</button>

            <div v-if="answer">
                <div>answer:</div>
                <div class="field has-addons">
                    <p class="control">
                        <span class="button has-text-info" @click="clipboard(answer)">
                            <i class="fas fa-copy"></i>
                        </span>
                    </p>
                    <p class="control">
                        <input class="input durak-readonly" v-model="answer" readonly></input>
                    </p>
                </div>

                <div>remote candidate:</div>
                <input class="input" v-model="remote_ice_candidate"></input>
                <button class="button" @click="accept_remote_ice_candidate">connect</button>
            </div>

            <div v-if="connected">
                <div>local data:</div>
                <textarea class="textarea" v-model="local_data"></textarea>
                <div>remote data:</div>
                <textarea class="textarea durak-readonly" v-model="remote_data" readonly></textarea>
            </div>
        </div>
    </div>

    <script>
        function uuidv4() {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
            );
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        class Card {
            static Ranks = '6789TJQA';
            static Suits = '♠♥♦♣';

            static value(card) {
                return Card.Ranks.indexOf(card[0]) + 6;
            }

            static rank(card) {
                return card[0];
            }

            static suit(card) {
                return card[1];
            }
        };

        class Game {
            static new(player_ids) {
                const game = new Game();
                game.id = uuidv4();
                game.player_ids = shuffle(player_ids);

                // Prepare deck.
                game.deck = [];
                for (let rank of Card.Ranks) {
                    for (let suit of Card.Suits) {
                        game.deck.push(rank + suit);
                    }
                }
                shuffle(game.deck);
                game.trump = Card.suit(game.deck[0]);

                // Distribute cards.
                game.hands = {};
                for (let player_id of game.player_ids) {
                    game.hands[player_id] = [];
                    for (let i = 0; i < 6; i++) {
                        game.hands[player_id].push(game.deck.pop());
                    }
                }
                game.#sort_hands();

                // Determine player order.
                let lowest_trump_value = Infinity;
                game.active_player_idx = 0;
                for (let player_idx = 0; player_idx < game.player_ids.length; player_idx++) {
                    const player_id = game.player_ids[player_idx];
                    for (let card of game.hands[player_id]) {
                        if (Card.suit(card) == game.trump && Card.value(card) < lowest_trump_value) {
                            lowest_trump_value = Card.value(card);
                            game.active_player_idx = player_idx;
                        }
                    }
                }

                // Define board state.
                game.board = [];
                game.discard = [];

                return game;
            }

            get state() {
                return JSON.stringify(this);
            }

            static load(state) {
                return Object.assign(new Game(), JSON.parse(state));
            }

            get active_player() {
                return this.player_ids[this.active_player_idx]
            }

            get defending_player_idx() {
                return (this.active_player_idx + 1) % this.player_ids.length
            }

            get defending_player() {
                return this.player_ids[this.defending_player_idx]
            }

            #sort_hands() {
                for (let hand of this.hands) {
                    hand.sort((lhs, rhs) => {
                        if (Card.suit(lhs) != Card.suit(rhs)) {
                            if (Card.suit(lhs) == game2.trump) {
                                return 1;
                            }
                            if (Card.suit(rhs) == game2.trump) {
                                return -1;
                            }
                            return (Card.suit(lhs) < Card.suit(rhs)) ? -1 : 1;
                        }
                        if (Card.value(lhs) != Card.value(rhs)) {
                            return (Card.value(lhs) < Card.value(rhs)) ? -1 : 1;
                        }
                        return 0;
                    })
                }
            }

            end_turn() {
                const board_cards = [];
                let defense_was_successful = true;
                for (let stack of this.board) {
                    if (stack.length == 1) {
                        defense_was_successful = false;
                    } else if (stack.length != 2) {
                        throw `Board state corrupted: unexepected stack of size ${stack.length}`
                    }
                    board_cards = board_cards.concat(stack);
                }

                // TODO: Draw cards, #sort_hands.
                // TODO: Announce non-losers.
                // TODO: Check for loser.

                if (defense_was_successful) {
                    this.discard = this.discard.concat(board_cards);
                    this.active_player_idx = (this.active_player_idx + 1) % this.player_ids.length;
                } else {
                    this.hands[this.active_player] = this.hands[this.active_player].concat(board_cards);
                    this.active_player_idx = (this.active_player_idx + 2) % this.player_ids.length;
                }
            }

            validate_attack(player_id, card) {
                if (!this.player_ids.includes(player_id)) {
                    return {
                        is_valid: false,
                        reason: 'Invalid player id.',
                    };
                }

                if (!this.hands[player_id].includes(card)) {
                    return {
                        is_valid: false,
                        reason: 'Player does not have given card.',
                    };
                }

                if (player_id == this.defending_player) {
                    return {
                        is_valid: false,
                        reason: 'Defending player cannot attack.',
                    };
                }

                // If board is empty, validate player_id is active player.
                // If board is not empty, validate card rank is already on the board.

                if (this.board.length >= 6) {
                    return {
                        is_valid: false,
                        reason: 'Max attacks reached.',
                    };
                }

                return {
                    is_valid: true,
                    reason: '',
                };
            }

            attack(player_id, card) {
                const attack_info = this.validate_attack(player_id, card);
                if (!attack_info.is_valid) {
                    throw `Invalid attack: ${attack_info.reason}`;
                }

                this.board.push([card]);
                this.hands[player_id] = this.hands[player_id].filter(c => { return c != card; });
            }

            validate_defend(stack_idx, card) {
                if (!this.hands[this.defending_player].includes(card)) {
                    return {
                        is_valid: false,
                        reason: 'Player does not have given card.',
                    };
                }

                if (this.board.length <= stack_idx) {
                    return {
                        is_valid: false,
                        reason: 'No such attack exists.',
                    };
                }

                if (this.board[stack_idx].length >= 2) {
                    return {
                        is_valid: false,
                        reason: 'Attack already defended.',
                    };
                }

                if (Card.suit(this.board[stack_idx][0]) != Card.suit(card) && Card.suit(card) != this.trump) {
                    return {
                        is_valid: false,
                        reason: `Cannot defend ${Card.suit(this.board[stack_idx][0])} with ${Card.suit(card)}.`,
                    };
                }

                if (Card.suit(card) != this.trump && Card.value(this.board[stack_idx][0]) > Card.value(card)) {
                    return {
                        is_valid: false,
                        reason: `Cannot defend ${Card.rank(this.board[stack_idx][0])} with ${Card.rank(card)}.`,
                    };
                }

                return {
                    is_valid: true,
                    reason: '',
                };
            }

            defend(stack_idx, card) {
                const defend_info = this.validate_defend(stack_idx, card);
                if (!defend_info.is_valid) {
                    throw `Invalid defense: ${defend_info.reason}`;
                }

                this.board[stack_idx].push(card);
                this.hands[this.defending_player] = this.hands[this.defending_player].filter(c => { return c != card; });
            }
        };

        const vueobj = new Vue({
            el: '#app',
            data: {
                mode: '',
                conn: null,
                chan: null,
                offer: null,
                answer: null,
                ice_candidates: [],
                potential_offer: null,
                potential_answer: null,
                remote_ice_candidate: null,
                connected: false,
                local_data: '',
                remote_data: '',
            },
            watch: {
                local_data: function (val) {
                    const vm = this;
                    vm.chan.send(val);
                }
            },
            methods: {
                reset() {
                    const vm = this;
                    vm.mode = '';
                    vm.conn = null;
                    vm.chan = null;
                    vm.offer = null;
                    vm.answer = null;
                    vm.ice_candidates = [];
                    vm.potential_offer = null;
                    vm.potential_answer = null;
                    vm.remote_ice_candidate = null;
                    vm.connected = false;
                    vm.local_data = '';
                    vm.remote_data = '';
                },
                host() {
                    const vm = this;
                    vm.reset();
                    vm.mode = 'host';

                    vm.make_conn();

                    vm.conn.onnegotiationneeded = () => {
                        vm.conn.createOffer().then(
                            (offer_desc) => {
                                vm.conn.setLocalDescription(offer_desc);
                                vm.offer = JSON.stringify(offer_desc.toJSON());
                            },
                            (err) => {
                                console.log(`Failed to create session description: ${err.toString()}`);
                            }
                        );
                    }

                    vm.chan = vm.conn.createDataChannel('stuff');
                    vm.setup_chan();
                },
                join() {
                    const vm = this;
                    vm.reset();
                    vm.mode = 'join';

                    vm.make_conn();

                    vm.conn.ondatachannel = (evt) => {
                        vm.chan = evt.channel;
                        vm.setup_chan();
                    };
                },
                accept_offer() {
                    const vm = this;
                    vm.offer = vm.potential_offer;
                    vm.conn.setRemoteDescription(JSON.parse(vm.offer));
                    vm.conn.createAnswer().then(
                        (answer_desc) => {
                            vm.conn.setLocalDescription(answer_desc);
                            vm.answer = JSON.stringify(answer_desc.toJSON());
                        },
                        (err) => {
                            console.log(`Failed to create session description: ${err.toString()}`);
                        }
                    );
                },
                accept_answer() {
                    const vm = this;
                    vm.answer = vm.potential_answer;
                    vm.conn.setRemoteDescription(JSON.parse(vm.answer));
                },
                accept_remote_ice_candidate() {
                    const vm = this;
                    vm.remote_ice_candidate;
                    vm.conn.addIceCandidate(JSON.parse(vm.remote_ice_candidate));
                },
                make_conn() {
                    const vm = this;
                    vm.conn = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                    vm.conn.onicecandidate = (evt) => {
                        if (evt.candidate) {
                            vm.ice_candidates.push(JSON.stringify(evt.candidate.toJSON()));
                        }
                    };
                },
                setup_chan() {
                    const vm = this;
                    vm.chan.onopen = () => {
                        vm.connected = true;
                    };
                    vm.chan.onclose = () => {
                        vm.connected = false;
                    };
                    vm.chan.onmessage = (evt) => {
                        vm.remote_data = evt.data;
                    };
                },
                clipboard(text) {
                    navigator.clipboard.writeText(text);
                }
            },
        });

    </script>

</body>

</html>